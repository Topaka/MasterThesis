%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint,10pt]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{listings}
\lstdefinelanguage{empty}{}
\lstset{language=empty,
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}
\usepackage{amsmath}
%\usepackage{footnote}

%\makesavenoteenv{tabular}
\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Discount Method for Programming Language Evaluation}
%\subtitle{Subtitle Text, if any}

\authorinfo{Svetomir Kurtev}
           {Department of Computer Science, Aalborg University}
           {svetomirkurtev@gmail.com}
\authorinfo{Tommy Aagaard Christensen}
           {Department of Computer Science, Aalborg University}
           {tommyaa@gmail.com}

\maketitle

\begin{abstract}
Studies in the field of programming language design evaluation have shown that there exists a gap between small internal methods and large-scale surveys and evaluation methods. This leaves language designers and especially students developing new programming languages with no low-cost solution for language evaluation. In this report, as a starting point, we examine the applicability of the discount usability method on programming languages by surveying relevant literature. Our findings suggest that it is good for examining the IDE and compiler of a language, but is less suited for examining the language’s design. For this reason, we conducted a usability evaluation experiment on a language without using an IDE or a compiler. This lead to the creation of a new method which used the discount usability method and the IDA method as a basis. The usability evaluation experiment was carried out on Quorum using programmers with experience in C and C\#. Most of the problems found in the evaluation were related to the programmers pre-existing expectations of a language. When comparing our results with Quorum’s data, however, we found several discrepancies.  The results show that our evaluation method could serve as a low-cost way of evaluating programming languages for language designers. 
\end{abstract}

\category{D.3}{Programming Languages}{}
\category{H.5.2}{Information Interfaces and Presentation (e.g., HCI)}{User Interfaces}[User-centered design]

% general terms are not compulsory anymore,
% you may leave them out
\terms
Programming Language Design Evaluation, User Evaluation

\keywords
Quorum, Usability Evaluation, Language Design

\section{Introduction}
Computer programming has increasing relevance to today's advancement of technologies. Therefore, existing and established programming languages are constantly improved and new ones are created to meet that demand. Some languages are considered arguably better than others in their intended purpose in the software industry. However, formal evaluation methods for assessing programming languages are very few and limited in their use and most evidence gathered to support such claims are anecdotal in nature\cite{StakingClaims}. 

In recent years, however, the scientific community has tried to rectify this.
In particular, the focus of the PLATEU conferences is the scientific evaluation of languages.
The basic observation is that language use and preference is highly opinionated, which lead to user-based evaluation being the norm for programming languages.
Commonly, the scientific community has made use of methods from social sciences, which usually requires studying a large number of subjects\cite{SocioPLT}\cite{AliceCS1}\cite{BlockOrNot}\cite{FromScratch}.

However, these methods are rather expensive since conducting a quantitative test requires a large group of people. Typically, this means programming language designers cannot do these tests before the language has already gained widespread use. Instead some designers have decided to use more qualitative and lightweight approaches for language evaluation. A commonly used lightweight approach is the discount usability evaluation method. Some examples of using the method in practice are: The language HANDS developed by Pane et al. designed specifically for children; Koitz and Slany used it to on Scratch and their phone language Pocket Code to compare the two; Faldborg and Pedersen used the method to test their spoken programming language LARM;  Faldborg and Nielsen have used it while conducting an empirical experiment on Dart and web-enabled IDE, developed by them, called DartPad.

The primary problem with the discount usability method in such context, as identified by Faldborg and Pedersen and Faldborg and Nielsen, is the difficulty of separating the feedback about the language design from the IDE.
These observations, along with our own experiences, lead us to believe that the discount usability evaluation method is good when evaluating the full package of a language with its IDE and compiler, but is less suited for evaluating language design.

To rectify this, we wanted to create a new evaluation method which will fill the gap between 
internal language analysis and the big and bulky industry programming evaluation methods\cite{AliceCS1}\cite{BlockOrNot}\cite{FromScratch}. This new method used the discount usability evaluation and the IDA methods as a basis, with the main difference being to avoid the use of a compiler or an IDE. To test this method, we used Quorum, an evidence-based programming language. This entailed conducting a qualitative experiment with six experienced programmers as participants.
We believe that our method would be a valuable, low-cost tool for user evaluation of programming languages. 

\section{Method}
To get acquainted with the discount usability method’s applicability on programming languages, we first used it on C\# in Visual Studio. The participants we used were experienced programmers familiar with C\#. The discount usability method we used was the one created by Andrew Monk et al. 1993 as presented in Designing Interactive Systems\cite{CooperativeEval}. To analyse the data from the test, we used the IDA method \cite{IDA}, as it is a lightweight method for prioritising encountered problems.

Based on our findings, we use both methods as a basis for creating a new evaluation method suitable for evaluating languages without the need of a compiler or an IDE. The method mainly relies on solving a set of programming tasks with the help of sample sheet which demonstrates the use of relevant constructs from the language being tested. Additionally, an interview, either in written or spoken form, serves the purpose of further elaborating on the most interesting problems the observer has noted during the process. The procedure of the method looks like this:

\begin{enumerate}
\item \textbf{Create tasks} These tasks are specific to the language, and should explore key features of the language. A useful tool to design tasks can be to create some scenarios you would expect a user to use your language in and what that user would need to do solve their task.
\item \textbf{Create a sample sheet} Based on the tasks, you now have a better idea of what a participant would need to know to solve those tasks. Keeping the sample sheet short or having a clear indexing of the samples can help participants browse the sample sheet. Having working code samples can help give a better understanding of the overall structure of code in the language.
\item \textbf{Estimate the task length} Taking time of how fast you can solve the tasks will give an idea of how long the experiment will take per participant. Do note that the participants will likely take longer to solve the tasks since they have to get acquainted with the language first. It can be okay to have more tasks than what you expect a participant to be able to solve, but the later tasks would need to explore less important features, and the participant needs to be made aware of not being expected to solve all of them.
\item \textbf{Prepare setup} The specifics of the setup can vary from a full blown usability lab to pen and paper. The advantage of a flexible setup, like pen and paper or a laptop with a text-editor, is the convenience it allows for potential participants. Often the experiment will be recorded to better review the process of solving the tasks, in which case the necessary utilities for this needs to be prepared.
\item[-] (optional) \textbf{Conduct a pilot test} A pilot test can let you discover and fix any problems in your tasks, sample sheet, task estimate and setup before conducting the experiment on the full number of participants. It does, however, require an additional participant and time.
\item \textbf{Gather participants} The golden rule for number of participants is five. More than that and most of the encountered problems are ones you already have observed, though the repetition can reinforce observations. Less than that and you tend to have several problems left undiscovered, though some data is generally still better than none.
\item \textbf{Start the experiment} Make sure to tell the participant that it is the language being tested and not them, to alleviate some unnecessary nervousness.
\item \textbf{Keep the participant talking} Try to make the participant talk about what they are thinking about solving the task at hand. During this time the facilitator may answer any questions the participant have about the language. The facilitator should try to avoid talking about how to solve the tasks, but it may be necessary if the participant need help getting started (or stopped in cases of overcomplicating tasks). The facilitator will confirm when a task is done, because the system won't give that kind of feedback.
\item \textbf{Interview the participant} After the test, have a brief interview with the participant where you can discuss the language, tasks etc. It can be useful to have some questions pre-written or create a questionnaire if there are many participants.
\item \textbf{Analyse data} After all the tests have been conducted, use the data to identify a list of problems encountered during the test. You can then categorise the problems using the following guidelines:
\begin{description}
\item[Cosmetic problems] are typos and small keyword and character differences that can easily be fixed by replacing the wrong part.
\item[Serious problems] are structural errors that usually impacts how the code is structured, but is usually small enough that it can be fixed with a few changes.
\item[Critical problems] are fundamental misunderstandings of how the language structures code and large structural errors that would require a revision of the algorithm.
\end{description}
Following this categorisation you will now have a prioritized list of things to improve on the language.
\end{enumerate}

Our method has two major differences from the discount usability method using the IDA method for evaluation.
The first big difference is the addition of a sample sheet step. The reason for this is that without an IDE or a compiler the language would be presented as blank paper, which does nothing to teach the user about how the language is written. Providing the user with examples and explanations of how the language works is then necessary to let them meaningfully program in the language.

The other big difference is the how the problems are prioritised. The IDA method uses time spent on overcoming a problem to categorise its severity. Our setup makes the user either work in a generic text editor or on a piece of paper neither of which give any feedback about the correctness of the code written. This means the participants would not necessarily discover any problems in their solutions and would therefore not spend time on solving those problems.
This makes time a poor measure for problem severity, which caused us to instead estimate the severity based on how much code would need to be changed to fix the problems.

\subsection{Experiment setup}
The new method was tested in an experiment setup by using it on an unfamiliar programming language to avoid bias from pre-existing knowledge about the language. Since we did not have a newly created language at our disposal, we decided to use an evidence-based programming language Quorum, which our participants were unlikely to be familiar with. Most of our participants were experienced programmers,  holding a degree in Computer science, and having knowledge about C and C\# and several programming languages (e.g. Java, F\#, Python, Pascal). We had a total of six participants taking part in the main experiment, with one additional person as a pilot test participant.

The experiment was conducted using a text-editor on a laptop.
The main reason for this over pen and paper, was to make recording easier.
The text-editor we used was Notepad++\cite{Notepad}.
Notepad++ has some features to assist programming, most notably an auto-completer which uses words already written in the text as suggestions.
However, since these features are language-agnostic and the auto-completer would only prevent false positives from minor typos and not language misunderstandings, this was deemed acceptable.
To record the screen Microsoft Game DVR was used.
Due to the poor quality of the inbuilt laptop microphones, a smartphone was used to record the audio.

\subsubsection{Task Sheet}
For our task sheet, we devised several smaller tasks, each addressing different features and constructs of Quorum. We drew heavy inspiration for some of the tasks from Codekata \cite{Codekata} since some of the katas were simple to understand yet conveyed the essence of a particular feature, present in the tested language.
Although each task had an intended purpose with a clear goal, their design allows more than one possible solution which gave the participants the freedom to experiment with the language.
\begin{itemize}
\item The first task had the intended purpose of testing arithmetic expressions and the use of data types.
\item The second task had the purpose of testing containers in the language (such as arrays) and control structures.
It also tested responsible code modification since there was a certain degree of intended repetitiveness in the subtasks which warranted careful reusing of code segments .%might not be good to point out
\item The third task was for testing the concept of classes and inheritance.
\item The final task was testing operations on strings, including the exercise of in-build actions specifically useful for splitting text segments.
\end{itemize}
The tasks were scheduled to be solved in about an hour, though the final task was expected to extend beyond that timeframe.

\subsubsection{Sample Sheet}
Alongside the task sheet, a sample sheet was created in order to to provide examples of code that the participant could use to learn what was necessary from the language in order to solve the tasks. Working samples of code were used since it tends to give a more wholesome picture of how the code should look, without resorting to detailed description of how everything works. 

\subsubsection{Interview sheet}
For the interview, we created an interview sheet with five questions addressing the overall experience of the experiment.
These questions were not meant to replace the open discussion but rather serve as a baseline for the direction of the discussion and to ensure some specific areas were covered in the discussion.
Questions \#1, \#2 and \#3 were about the language and primarily served to get the participants own thoughts about it.
While there were some potential overlap in these questions, they could help some people talk more, and they helped categorise the feedback.
Question \#4 focused on getting feedback about our task and sample sheet.
Question \#5 asked about the experience of coding without a compiler since it is the biggest change for our method.
During the interview, the subject would usually be made aware of most of the otherwise unmentioned errors, to be able to provide a more informed discussion.

\section{Results}
In this section, we describe and divide the identified problems, according to the categorization described earlier. Table \ref{QuorumProblemResult} lists all the problems in their respective category, but for the sake of brevity, we will focus only on the most interesting ones. 

\begin{enumerate}
\item \textbf{Not using the \lstinline!end! keyword at all} - this would affect the overall validity of the program because the scoping rules in Quorum are defined in conjunction with the \lstinline!end! keyword. This shows a fundamental misunderstanding of how scoping works in the language
\item \textbf{The lack of constructors with parameters in Quorum} - Quorum does not support constructors with parameters which might be problematic for the participants, having experience with other languages where this feature is common. It both causes the participants to invoke syntax in the class that is not supported, and have difficulties instantiating classes. Since this is a significant difference in how the code should be structured, it is considered critical.
\item \textbf{Misunderstanding the effect of \lstinline!Sort()! on arrays of objects} - The inbuilt sorting function for arrays does not have access to the properties of the objects and therefore does not sort them by any of those. This would have the consequence of code, written with the assumption that it works, be most likely wrong, which means recovery would require a full rewrite of the algorithm. This makes the problem critical. It is possible that with the use of a compiler the participant would discover and recover much easier, which could mean the problem would potentially be considered serious.
\end{enumerate}

\begin{table*}[]
\renewcommand{\arraystretch}{1.5}
\begin{minipage}[c]{\textwidth}
\begin{center}
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
\textbf{Critical}                                          & \textbf{Serious}                                                   & \textbf{Cosmetic}                                                                                        \\ \hline
Not using the \lstinline!end! keyword at all               & Not using the \lstinline!end! keyword to end the scope of if-statements      & Using keywords and symbols from C\# instead of Quorum\footnote{dot (\lstinline!.!) instead of colon (\lstinline!:!), \lstinline!&&! instead of \lstinline!and!, \lstinline!||! instead of \lstinline!or!, \lstinline!float! instead of \lstinline!number!, \lstinline!string! instead of \lstinline!text!, \lstinline!==! in conditional statements instead of \lstinline!=!, \lstinline!int! instead of \lstinline!integer! and \lstinline!bool! instead of \lstinline!boolean!} \\ \hline
The lack of constructors with parameters in Quorum         & Forgetting to increment the iterator in a repeat while loop        & The lack of aggregate operators in Quorum (e.g.\lstinline!+=!)                                           \\ \hline
Misunderstanding the effect of \lstinline!Sort()! on arrays of classes & The lack of common looping constructs (for-loops or foreach loops) &  Writing \lstinline!output! instead of \lstinline!return! as the keyword for a return statement \\ \hline
                                                           & Forgetting to import a library for containers (array)              & Typos in library importing                                                					           \\ \hline
                                                           & Not using \lstinline!elseif! to avoid having to close an additional scope    & Mistyping \lstinline!integer! as \lstinline!integar!                                 \\ \hline
                                                           & Not resetting inner loop iterator between loops                    & Accidentally used \lstinline!0! instead of \lstinline!O! in variable name						           \\ \hline
                                                           &                                                                    & Mistyped the \lstinline!is! keyword as \lstinline!ia!					                                   \\ \hline
                                                           &                                                                    & Forgot to add the \lstinline!repeat! keyword		                                                       \\ \hline
\end{tabular}
\end{center}
\caption{The table of identified problems categorised by severity}
\label{QuorumProblemResult}
\end{minipage}
\end{table*}

\subsection{Comparison with Quorum's Evidence}
In their empirical experiments, Stefik and Gellenbeck \cite{EmpStudiesonStimuli} gathered many statistically significant results regarding keyword choices. Given that they try to primarily address visually impaired people and novice programmers, selecting the most intuitive words seems like a logical choice. For one of their  experiments \cite{EmpStudiesonStimuli}, they divided the participants in two groups - novices and experienced programmers to find out if there is a significant discrepancy in the results between the two groups. Every keyword choice was ranked in two tables by mean value and standard deviation. Since we conducted our experiment with people having programming experience, we are primarily interested in the results of the second group. For the purpose of our evaluation method, we will not mention every single word choice they rated but rather the ones which are coinciding with the problems we identified from the IDA evaluation in section \ref{section: Problem Categorization}. Additionally, we would also relate two of the empirical studies from Stefik and Siebert \cite{Empiricalinvestigation} and their findings about keyword choices. This would help us to make a comparison between the authors findings and the results from our evaluation, essentially giving an additional degree of credibility to the method if similarities are found.

\begin{itemize}
\item In the results for the concepts of AND, OR and XOR, Stefik and Gellenbeck \cite{EmpStudiesonStimuli} found that for the AND concept, using \lstinline!&&! and \lstinline!and! performed quite well. Their results showed that these words are actually popular and thus intuitive to use. As for the logical OR concept, the \lstinline!or! keyword was placed first, being significantly better the the second highest one - the \lstinline!||! operator, which is present in many popular programming languages. Last but not least, the XOR logical operator, the \lstinline!or! was rated highest which can be attributed to the fact that the participants did not know how to call an operation which "took a behavior when one condition was true but not both".
\item Stefik and Gellenbeck \cite{EmpStudiesonStimuli} settled on using a single equals (\lstinline!=!) sign for assignment statements and for testing equality since that is what they thought would make most sense. Although this might be true for the novice group (single equals (\lstinline!=!) sign was ranked highest), the experienced programmers group did not even rate the single equals in the top 3, rating the double equals (\lstinline!==!) as highest instead. This was not verified until one of the later empirical studies by Stefik and Siebert \cite{Empiricalinvestigation}.
\item For the concept of "Taking a behaviour" the authors considered several word choices such as \lstinline!function!, \lstinline!action! and \lstinline!method!. The novices ranked the \lstinline!action! word the highest, while the experienced programmers - \lstinline!operation!, followed by \lstinline!action!, \lstinline!method! and \lstinline!function!. However, the authors admit that this particular results should be further investigated, since the participants might have understood the description of the concept as something other than completely capturing the idea of a function.
\item Quorum makes use of the keyword \lstinline!repeat! over \lstinline!for!, \lstinline!while! or \lstinline!cycle! (see Sanchez and Flores \cite{SanchezData}) following a study which shows that \lstinline!repeat! represents the concept of iteration significantly better than the the aforementioned words \cite{EmpStudiesonStimuli}.
\end{itemize}

Based on the results from Stefik and Siebert \cite{Empiricalinvestigation}, the programmers group found \lstinline!==! to be intuitive as the boolean equals operator, which matches our observation of the participants often using \lstinline!==! instead of \lstinline!=! notation. For many of our other problems where our participants used the wrong syntax, Stefik and Siebert\cite{Empiricalinvestigation} did have comparable results were both the wrong and the correct syntax was found intuitive by their programmers group. These are: 
\begin{itemize}
\item Dot (\lstinline!.!) versus colon (\lstinline!:!)
\item using an aggregate operator (\lstinline!x += 1!) versus an arithmetic operator (\lstinline!x = x + 1!)
\item \lstinline!&&! versus \lstinline!and! for logical AND
\item \lstinline!||! versus \lstinline!or! for logical OR
\item data types wording (\lstinline!float! versus \lstinline!number!, \lstinline!string! versus \lstinline!text! and \lstinline!bool! versus \lstinline!boolean!)
\end{itemize}

It is possible that a lot of these cases were the result of a participant just glancing over the sample sheet, instead of having a more thorough look at the syntax on the sample sheet. Since the constructs looked intuitive, they did not notice or remember that it was different and thus just used the syntax they were used to from other programming languages. Interestingly, our results about the looping constructs contradicts the results from \cite{Empiricalinvestigation}. Our participants often lamented the lack of a \textit{for} or \textit{foreach} loop and had a lot of errors in using the iterator for the \textit{while} loop. This is in contrast to the papers results where their programmers did not find \lstinline!for! among the most intuitive and found \lstinline!foreach! among the least intuitive keywords for looping. However, the results are not directly contradictory as the paper's questions about intuitiveness was focused on the syntax, while our participants problems were more about lacking the functionality of a looping construct with inbuilt iterator handling. A more direct contradiction is that our participants often found the \lstinline!repeat! keyword unnecessary, despite the paper listing it as one of the most intuitive keywords for looping. This could be a side effect of us only demonstrating the \textit{repeat while} loop in our sample sheet, since that loop looks exactly like the \textit{while} loop they are used to but with an extra keyword in front. 

A lot of our results were unsurprising.
Quorum is a language that uses evidence about programming to design a language that is intuitive for novices.
Since our participants were experienced programmers though, it would be expected that a lot of the errors encountered would be related to this mismatch.
Especially the critical error with lacking constructors with parameters, showed a large mismatch in what an experienced programmer expected from a class compared to what was proven to be more user-friendly\cite{ParamConstructors}.
Likewise the lack of a for- or foreach loop and the resulting iterator handling problems experienced by our participants, showed that they had a habit of handling the iterator in the looping construct.
This functionality, however, could make the construct less practical for novices, as they might get a better understanding of the same functionality by writing the statements separately.
More surprisingly we had a participant who never used the \lstinline!end! keyword.
In the discussion he explained this was because he thought indentation was used to control scope.
He felt that since indentation is a good practice that all programmers should use anyway, it would make sense to make the language use and enforce this.
This would be especially true for a beginner language, as the beginners are those who need to learn to use indentation.
This again showed that experienced programmers were likely to draw from their previous experiences rather than thoroughly examine the sample sheet.

\section{Discussion}
The results from the previous section addressed some potential problems encountered when working with a language such as Quorum. This section will elaborate on how that can be extended to other programming languages and how our method could be used in a customized manner.

Comparing our results with Quorum's evidence has shown that our method gets comparable results to other methods, but with a significantly lower amount of participants.
Most of Quorum's evidence about experienced programmers has, however, been focused on just the syntax.
This means that most of the comparable data lies in our cosmetic errors, which are usually the least interesting problems from a usability standpoint.
The more serious problems tend to either contradict or not be addressed by Quorum's evidence, though in most cases, this is a result of the mismatch in target group between novice and experienced programmers.
One noticeable problem we encountered in the execution of our test was participants freezing at the very beginning.
They were unsure how to start as they could not figure out what format of the solution they should use.
For most of the participants this was not a big hurdle, as they would either just pick one way of doing it or consult the facilitator.
However, for some participants, having a discussion while programming was unnatural.
One way to prevent this could be to have some pre-written code that the participant should instead fill out.
It does however sacrifice some of the potential data about the language that a more free-form task can give.

After conducting both of our experiments, a very interesting observation can be made that an Integrated Development Environment (IDE), when used in conjunction with a programming language, contributes primarily to resolving cosmetic problems and mistakes associated strictly with the syntax of the given language. However, An IDE does not contribute that much to the facilitation process if the user gets "stuck", a state attributed to the critical problems from the IDA evaluation. Additionally, we noticed that even if people are experienced with a specific paradigm (participant \#2 from the usability evaluation in regards to C\#), they can still get into a position where they cannot continue with the experiment, given that they have to solve a task in a paradigm, different from what they are familiar with (participant \#2' experience with the F\# task). Further observations from the evaluation method showed that when people familiar with a specific paradigm (imperative, object-oriented) have to make use of an unfamiliar language, supporting such paradigm (Quorum is both imperative and object-oriented), they tend to disregard the syntax of the new language in place of a language they are familiar with. In the case with Quorum, most of the participants (\#1, \#3, \#4, \#5, \#6, \#7 and \#8) made use of syntax native to languages such as Java and C\#, supporting the same paradigms as Quorum.

\section{Threats to validity}
Conducting the experiment had some informal and qualitative conditions, which makes the validity face some threats. This section will describe the most prevalent of such threats.
\begin{itemize}
\item Participant sample - Although we collected some qualitative results, the experiment did not have a good representation of the general populace. The participant sample involved a small group, with very similar educational backgrounds, occupation, age and geological location. The involvement of a bigger and more diverse group might skew the results in a different direction.
\item Facilitating the participants - Since we did neither use a compiler nor an IDE for the experiment, the facilitator had to help on several occasions and the participants referred to him rather than the sample sheet.
\end{itemize}

\section{Conclusion}
We identified a gap in programming language evaluation between internal language analysis and the big industrial evaluation methods. In that regard, we wanted to explore whether HCI techniques could be applicable for the evaluation of programming languages.

In the context of HCI techniques, we have examined the usefulness of the discount usability method ( \ref{chapter:ExperimentEvaluation}) with the IDA method (\ref{section:IDA}) for data analysis on C\# along with examining literature for similar experiments.
In this examination we found that the discount usability method can be used to evaluate programming languages, but has some shortcomings.
The programming language’s IDE has a large effect on the results, often providing significant assistance which effectively eliminates many of the errors which might otherwise get caught in the language.
Based on the results, we believe that the discount usability method is good for testing a compiler and an IDE, but is less well suited for examining language design.

To create a method better suited for evaluating language design, we conducted an adapted usability experiment where we specifically avoided the use of an IDE or a compiler (\ref{chapter:MethodIntro}).
An added advantage of such a method is that it does not require the creation of any tools for the language before the language design can be tested, making it a low-cost and efficient solution.
For this experiment, we used the evidence-based language called Quorum, as it was less likely for our participant group to be familiar with it, yet it belongs to a programming paradigm they were familiar with.
We changed the way the problems are prioritised due to the discovery that since the system does not have a way of giving meaningful feedback to the participant, the participants would not encounter problems nor spend time fixing them.

Comparing the resulting data from the method with Quorum’s evidence showed us that most of the data was comparable though not strictly in agreement.
However, Quorum’s data was mostly centered around syntax choice and therefore was mostly only related to the cosmetic problems, which are the least interesting problems to consider.
The data suggests that our method will be better suited for getting some of the deeper problems with a programming language when compared to the syntax questionnaires used as evidence for Quorum.

We believe that we have created a method that can help fill the gap in programming language evaluation between internal language analysis and the big industrial evaluation methods.

\section{Future Works}
The results from the evaluation method show that this is a viable way of evaluating a programming language in a low-cost setup. However, there are still plenty of opportunities which can be taken into consideration for improving the method. This section provides a discussion of the most promising things that can be done in the future.

One of the things that could be done would be to conduct the usability experiment on Quorum, still with experienced programmers, using the Sodbeans environment. 
This would give a more direct comparison of the differences in the data gotten from using the usability experiment method versus our method.

Of course, simply conducting our method on more languages, and ideally by the language designers of these languages, would also give a lot of data about the method.
One way to facilitate this could be to spread the method to the 4th semester students in the engineering faculty (SW, DAT, IT) at Aalborg University.
Since these student have to design a language as part of their semester project, and could use the data to argument for their language design decisions, it would be an opportune way of testing the method in a low-risk environment.

While our method is good for finding problems in a programming language, it is less well suited to be used to compare the quality of programming languages.
It could be interesting to look at creating a method designed for that purpose, as such comparisons are commonly of interest to language designers looking to promote their language over existing ones.
One way of creating such a method from our method, could be to create a set of generalised tasks that would be applicable on all programming languages, which would give a solid common ground for the comparison.

Another thing worth exploring is using our method on novices.
Using experienced programmers makes it easier to convey how to program in a language, as they already know how to program, and it  makes sense when programmers are the target group for the language.
It does, however, mean that the data tend to be biased towards the languages the programmers already know.
Using novices avoids this bias and is obviously useful for languages designed for them.

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks
We would like to thank Bent Thomsen for his guidance while making this paper possible. 
In addition, we would like to thank all of the students who were willing to share their time with us as participants in our experiments.\cite{smith02}

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}
