\section{Tasks}
The concept of programming is essentially devising a mental plan for solving a particular problem, and transforming that into a workable solution by making use of some programming language. The solution to a problem might vary for different implementations since different paradigms have different approaches, but usually the essence of said solution does not change. Devising a set of programming tasks which are not targeted at a specific language implementation is a daunting task, since many paradigms have to be taken into account at the same time. Additionally, the tasks have to be interesting and engaging enough so that the participants can focus on the solution. As described previously in section \ref{subsection:C Task}, for our usability experiment we devised one big task with several subtasks for the C\# part, each as a prerequisite for the next one. It followed the theme of a role playing game and it mainly revolved around the use of inheritance. The second task, addressing F\# in section \ref{subsection:F Task}, was still modelled as a game and it revolved around a robot finding a goal in a world of tiles, essentially relying on the use of recursion as a concept. Although we did not count time as an important factor for both our experiments, we still had to put a specific time constraints on how long a participant can work on the tasks. The main reason for that is our aim is process-oriented rather than result-oriented, which make it easier for programming language designers in the future to replicate our experiments.\\ Based on the feedback from the participants, we got a better estimate of how much time each task takes for its completion and how relevant it is in the given context. Furthermore, this served as a stepping stone towards gaining a better understanding of how to design tasks with more general context i.e. being solvable in more than one programming paradigm. The design behind our task sheet was mainly influenced by the use of Quorum as our experiment language, but that could easily be used by language designers as a template for devising their own tasks, tailored towards a specific language of choice. Additionally, the scope of each of the tasks  can be used as a guideline, giving a more controllable and predictable time frame (all of the tasks together amount for approximately 1 hour). 

For our evaluation method, we devised several smaller tasks, each addressing different features and constructs of the selected language - in this case Quorum. We drew heavy inspiration for some of the tasks from Codekata \cite{Codekata} since some of the katas were simple to understand yet conveyed the essence of a particular feature, present in the tested language.
Although each task had an intended purpose with a clear goal, their design allows more than one possible solution which gave the participants the freedom to experiment with the language.
\begin{itemize}
\item The first task had the intended purpose of testing arithmetic expressions and the use of data types.
\item The second task had the purpose of testing containers in the language (such as arrays) and control structures.
It also tested responsible code modification since there was a certain degree of intended repetitiveness in the subtasks which warranted careful reusing of code segments .%might not be good to point out
\item The third task was for testing the concept of classes and inheritance. The design of this task was inspired by the task used in the C\# section of our usability experiment in section \ref{subsection:C Task}.
\item The final task was testing operations on strings, including the exercise of in-build actions specifically useful for splitting text segments.
\end{itemize}

The final task sheet can be found in \appref{chapter:taskSheet}.
