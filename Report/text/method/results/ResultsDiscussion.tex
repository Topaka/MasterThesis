\chapter{Results}
\label{chapter:Results}
This section will highlight the results from the evaluation method and a discussion of how the data can serve as a future reference to language designers and people interested in conducting their own evaluation methods. Initially, we conducted a pilot test with one participant in order to test the overall setup of the experiment and get some pointers of what areas could be further improved. Similarly to how the results were evaluated in Chapter \ref{chapter:ExperimenteEvaluation}, we made use of the IDA method \cite{IDA} to categorize the problems we identified based on their importance and severity. Furthermore, we compared our results with the exiting findings about the evaluation of Quorum in order to prove the validity of our method.

\input{./text/method/results/PilotTest.tex}

\section{Problems categorization}
\label{section: Problem Categorization}
The premise of the experiment is to try to divide the IDE from the language which does not warrant using a compiler.
However, since this means the system cannot give any feedback, the usual rules for categorisation can not apply.
For this reason, we would try to reason where each problem should be and would it make a difference given that a compiler have been used instead.
The general guidelines we have used for this categorisation are:
\begin{description}
\item[Cosmetic problems] are typos and small keyword and character differences that can easily be fixed by replacing the wrong part.
\item[Serious problems] are structural errors that usually impacts how the code is structured, but is usually small enough that it can be fixed with a few changes.
\item[Critical problems] are fundamental misunderstandings of how the language structures code and large structural errors that would require a revision of the algorithm.
\end{description}

\begin{table}[!h]
\centering
\renewcommand{\arraystretch}{1.5}
\label{QuorumProblemResult}
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
\textbf{Critical}                                          & \textbf{Serious}                                                   & \textbf{Cosmetic}                                                                                        \\ \hline
Not using the “end” keyword at all                         & Not using the “end” keyword to end the scope of if-statements      & Using colon (“:”) instead of dot (“.”)                                                                   \\ \hline
The lack of constructors with parameters in Quorum         & Forgetting to increment the iterator in a repeat while loop        & The lack of aggregate operators in Quorum (e.g.“+=”)                                                        \\ \hline
Misunderstanding the effect of Sort() on arrays of classes & The lack of common looping constructs (for-loops or foreach loops) & Using conditional AND and OR as “\&\&” and “||” instead of “and” and “or” keywords, as defined in Quorum \\ \hline
                                                           & Forgetting to import a library for containers (array)              & Using the “float” instead of “number” keyword                                                            \\ \hline
                                                           & Not using “elseif” to avoid having to close an additional scope    & Using “string” instead of the “text” keyword                                                             \\ \hline
                                                           & Not resetting inner loop iterator between loops                    & Writing “output” instead of “return” as the keyword for a return statement                               \\ \hline
                                                           &                                                                    & Using “==” in conditional statements instead of “=”                                                      \\ \hline
                                                           &                                                                    & Using “int” instead of “integer”                                                                         \\ \hline
                                                           &                                                                    & Using “bool” instead of “boolean”                                                                        \\ \hline
                                                           &                                                                    & Typos in library importing                                                                               \\ \hline
                                                           &                                                                    & Mistyping “integer” as “integar”                                                                         \\ \hline
                                                           &                                                                    & Accidentally used 0 instead of O in variable name                                                        \\ \hline
                                                           &                                                                    & Mistyped the “is” keyword as “ia”                                                                        \\ \hline
                                                           &                                                                    & Forgot to add the “repeat” keyword                                                                       \\ \hline
\end{tabular}
\caption{The table of identified problems categorised by severity}
\end{table}

\textbf{Critical problems}
\begin{enumerate}
\item \textbf{Not using the “end” keyword at all} - this would affect the overall validity of the program because the scoping rules in Quorum are defined in conjunction with the “end” keyword. This shows a fundamental misunderstanding of how scoping works in the language
\item \textbf{The lack of constructors with parameters in Quorum} - Quorum does not support constructors with parameters which might problematic for the participants, having experience with other languages where this feature is common. It both causes the participants to invoke syntax in the class that is not supported, and have difficulties instantiating classes. Since this is a significant difference in how the code should be structured, it is considered critical.
\item \textbf{Misunderstanding the effect of Sort() on arrays of objects} - The inbuilt Sort function for arrays does not have access to the properties of the objects and therefore does not sort them by any of those. This would have the consequence of code, written with the assumption that it works, be most likely wrong, which means recovery would require a full rewrite of the algorithm. This makes the problem critical. It is possible that with the use of a compiler the participant would discover and recover much easier, which could mean the problem would potentially be considered serious.\\\\
\end{enumerate}


\textbf{Serious problems}
\begin{enumerate}
\item \textbf{Not using the “end” keyword to end the scope of if-statements} - Although this problem looks similar to the first problem defined in Critical problems, the difference is that it is more likely to be an overlook than a misunderstanding of the scoping rules in Quorum. Also single-line if-statements might be present in other languages and not in Quorum.\\
\item \textbf{Forgetting to increment the iterator in a repeat while loop} - This could be considered an oversight on the participant’s part, attributed to how the repeat-while construct works in Quorum compared to how usually for-loops are used, and therefore it was not critical. However, it is still considered a serious problem because of the impact it has on the structural correctness of the code.
\item \textbf{The lack of common looping constructs (for-loops or foreach loops)} - This is considered a serious problem for few reasons. Firstly, it warrants the use of the repeat-while construct as a part of Quorum, which might not be so intuitive for people coming with backgrounds in other languages, where these constructs are present. Secondly, this might compound to the previous problem described in this section which would have a high impact on the validity of the written program. 
\item \textbf{Forgetting to import a library for containers (array)} - Containers in Quorum, and specifically arrays, have to imported first before being used. This is considered a serious problem since it might have a high impact on the validity of the program. 
\item \textbf{Not using “elseif” to avoid having to close an additional scope} - This problem is serious because it shows a lack of understanding the finer points of scoping in an if-else chain. Problematic since “else if” is also valid syntax, but carries unintended consequences.
\item \textbf{Not resetting inner loop iterator between loops} - Similarly to serious problem 2, this could be considered an oversight on the participant’s end due to previous experience with other programming languages.
\end{enumerate}

\textbf{Cosmetic problems}
\begin{enumerate}
\item \textbf{Using colon (“:”) instead of dot (“.”)} - This is considered a cosmetic problem since does not affect the structure of the program being only an exchange of a single character. It could be said that most of the participants had a programming bias given their background in other programming languages where the dot notation is common.
\item \textbf{The lack of aggregate operators in Quorum (e.g.“+=”)} - This is considered a cosmetic problem since it does not affect the correctness of the program but it is rather a matter of convenience for the participants.
\item \textbf{Using conditional AND and OR as “\&\&” and “||” instead of “and” and “or” keywords, as defined in Quorum}  - This problem is considered cosmetic because the participants did not use the correct keywords in the context but had the proper intentions to do so. This could be attributed to the simple matter of not properly reading the sample sheet to find the proper keywords and using the ones they know from other languages instead.
\item \textbf{Using the “float” instead of “number” keyword} - This is considered a cosmetic problem because it does not have a big impact on the program’s correctness but rather is using a naming convention from other programming languages
\item \textbf{Using “string” instead of the “text” keyword} - this is the same as with the previous cosmetic problem
\item \textbf{Writing “output” instead of “return” as the keyword for a return statement} - This is cosmetic because it is mostly a result of our sample sheet using “output” often, while the participants were more commonly expected to write code returning something and had a familiarity with the “return” keyword from other languages.
\item \textbf{Using “==” in conditional statements instead of “=”} - Similarly to previous cosmetic problems, the main reason behind this problem is that most of the participants had experience with other programming languages where the “==” notation is common and in turn had a particular bias against using the “=” notation.
\item \textbf{Using “int” instead of “integer”}  - same as with cosmetic problem 4
\item \textbf{Using “bool” instead of “boolean”} - same as with cosmetic problem 4
\item \textbf{Typos in library importing} - This is a simple case of having small typos when writing the import code. Easily fixed and a cosmetic problem.
\item \textbf{Mistyping “integer” as “integar”}  - this is a cosmetic problem since it is a simple typing mistake and it does not have any impact on the validity of the program.
\item \textbf{ Accidentally used 0 instead of O in variable name}  - Again another small typo and therefore cosmetic.
\item \textbf{Mistyped the “is” keyword as “ia”}  - similar to cosmetic problem 12
\item \textbf{Forgot to add the “repeat” keyword} - This problem is considered cosmetic since it does not have a significant impact on the correctness of the program.
\end{enumerate}

\section{Comparison with Quorum's evidence}
In their empirical experiments, Stefik and Gellenbeck \cite{EmpStudiesonStimuli} gathered many statistically significant results regarding keyword choice. Given that they try to primarily address visually impaired people and novice programmers, selecting the most intuitive words seems like a logical choice. For one of their  experiments \cite{EmpStudiesonStimuli}, they divided the participants in two groups - novices and experienced programmers to find out if there is a significant discrepancy in the results between the two groups. Every keyword choice was ranked in two tables by mean value and standard deviation. Since we conducted our experiment with people having programming experience, we are primarily interested in the results of the second group. For the purpose of our evaluation method, we will not mention every single word choice they rated but rather the ones which are coinciding with the problems we identified from the IDA evaluation in section \ref{section: Problem Categorization}. Additionally, we would also relate two of the empirical studies from Stefik and Siebert \cite{Empiricalinvestigation} and their findings about keyword choices. This would help us to make a comparison between the authors findings and the results from our evaluation, essentially giving an additional degree of credibility to the method if similarities are found.

\begin{itemize}
\item In the results for the concepts of and,or and xor, Stefik and Gellenbeck \cite{EmpStudiesonStimuli} found out that for the and concept,  using a single ampersand with and performed quite well, statistically comparable to and. Contrary to how many programming languages make use of "\&" for bitwise and and "\&\&" for logical and, their results showed that these words are actually not that popular and thus not so intuitive to use. As for the logical or concept, the or keyword was placed first, being significantly better the the second highest one - the "||" operator, which is present in many popular programming languages. Last but not least, the xor logical operator, the or was rated highest which can be attributed to the fact that the participants did not know how to call an operation which "took a behavior when one condition was true but not both".
\item Stefik and Gellenbeck \cite{EmpStudiesonStimuli} settled on using a single equals ("=") sign for assignment statements and for testing equality since that is what they thought would make most sense. Although this might be true for the novice group (single equals ("=") sign was ranked highest), the experienced programmers group did not even rate the single equals in the top 3, rating the double equals ("==") as highest instead. This was not verified until one of the later empirical studies by Stefik and Siebert \cite{Empiricalinvestigation}.
\item For the concept of "Taking a behaviour" the authors considered several word choices such as function,action and method. The novices ranked the action word the highest, while the experienced programmers - operation, followed by action,method and function. However, the authors admit that this particular results should be further investigated since the participants might have understood the description of the concept as something other than completely capturing the idea of a function.
\item Quorum makes use of the keyword repeat over for or while, or cycle (see Sanchez and Flores \cite{SanchezData}) following a study which shows that repeat represents the concept of iteration significantly better than the the aforementioned words \cite{EmpStudiesonStimuli}.  
\end{itemize}

Based on the results from Stefik and Siebert \cite{Empiricalinvestigation}, the programmers group found "==" to be intuitive as the boolean equals operator, which matches our observation of the participants often using "==" instead of "=" notation. For many of our problems where our participants used the wrong syntax, \cite{Empiricalinvestigation} did have comparable results were both the wrong and the correct syntax was found intuitive by their programmers group. These are: 
\begin{itemize}
\item Dot (".") versus colon (":")
\item using an aggregate operator (x += 1) versus an arithmetic operator (x = x + 1)
\item logical and (\&\&) versus and
\item logical or (||) versus or 
\item data types wording (float versus number, string versus text and bool versus boolean). 
\end{itemize}

It is possible that a lot of these cases were the result of a participant just glancing over the sample sheet. Since the constructs looked intuitive, they did not notice or remember that it was different and thus just used the syntax they were used to. Interestingly, our results about the looping constructs contradicts the results from \cite{Empiricalinvestigation}. Our participants often lamented the lack of a \textit{for} or \textit{foreach} loop and had a lot of errors in using the iterator for the \textit{while} loop. This is in contrast to the papers results where their programmers did not find "for" among the most intuitive and found "foreach" among the least intuitive keywords for looping. However, the results are not directly contradictory as the paper's questions about intuitiveness was focused on the syntax, while our participants problems were more about lacking the functionality of a looping construct with inbuilt iterator handling. A more direct contradiction is that our participants often found the "repeat" keyword unnecessary, despite the paper listing it as one of the most intuitive keywords for looping. This could be a side effect of us only demonstrating the \textit{repeat while} loop in our sample sheet, since that loop looks exactly like the \textit{while} loop they are used to but with an extra keyword in front. 

\input{./text/method/results/InterviewResults.tex}
\input{./text/method/results/Discussion.tex}